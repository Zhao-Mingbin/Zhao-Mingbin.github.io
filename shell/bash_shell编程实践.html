<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bash shell编程实践</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Homepage</a></li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> shell 编程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../shell/shell编程.html"><strong aria-hidden="true">2.1.</strong> shell 编程</a></li><li class="chapter-item expanded "><a href="../shell/bash_shell编程实践.html" class="active"><strong aria-hidden="true">2.2.</strong> bash shell编程实践</a></li><li class="chapter-item expanded "><a href="../shell/linux速查.html"><strong aria-hidden="true">2.3.</strong> linux速查</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> C++学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C++学习/C++基础带目录.html"><strong aria-hidden="true">3.1.</strong> C++基础</a></li><li class="chapter-item expanded "><a href="../C++学习/C++进阶带目录.html"><strong aria-hidden="true">3.2.</strong> C++进阶</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> CFD学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../CFD学习/latex数学公式.html"><strong aria-hidden="true">4.1.</strong> latex数学公式</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bash-shell-编程实践"><a class="header" href="#bash-shell-编程实践">bash shell 编程实践</a></h1>
<p><strong>Shell</strong> 既是一套<strong>命令行工具</strong>（交互式地解释和执行用户输入的命令）也是一种<strong>脚本设计语言</strong>（定义有变量与参数，并提供了控制、循环、分支结构）。<a href="https://tiswww.case.edu/php/chet/bash/bashtop.html"><strong>Bash Shell</strong></a> 是由 GUN 官方项目提供的 Shell 解释器，名称源自于 <strong>B</strong>ourne <strong>A</strong>gain <strong>SH</strong>ell 的英文缩写，整合了传统 <strong>Korn Shell</strong> 以及 <strong>C Shell</strong> 的有效特性，并且尽量遵循<code>IEEE POSIX P1003.2/ISO 9945.2</code>规范，同时在编程与交互使用方面提供了大量的功能改进，因而在提供丰富功能的基础之上，展现出了良好的兼容特性，大多数<code>.sh</code>脚本可以无需移植修改即可交由 Bash Shell 来执行。</p>
<p><img src="bash_shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/media/logo-16323896707602-16326334128181.png" alt="img" /></p>
<p>当用户登入任意一款 Linux 操作系统时，初始化程序<code>init</code>都将会为用户启动一个<strong>Bash Shell</strong>命令解析器，其即可以用于解析命令行输入并与内核进行交互，也可以作为高效的脚本编程语言，运用其提供的变量、参数、循环、分支等编程语法特性，完成一些批量的自动化的任务处理工作，本文将会围绕 Bash Shell 的脚本编程特性，加以进行详细的分析、说明与示例。</p>
<h2 id="基础概念"><a class="header" href="#基础概念">基础概念</a></h2>
<p>Shell 脚本的解释过程就是从文件读入字符流，然后进行处理，最后将结果传送至某个<strong>文件</strong>，所以交互式 Shell 命令与 Shell 脚本在本质上并没有区别，只是 Shell 命令的输入是<strong>标准输入</strong>，输出是<strong>标准输出</strong>。</p>
<p>Shell 脚本的注释以<code>#</code>符号开始，一直到行末结束，例如可以在 Shell 命令行中输入以<code>#</code>开头的命令，则该命令将会被作为注释而忽略处理。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ # 这是一条注释
</code></pre>
<blockquote>
<p>按下【Ctrl + D】组合键将会在<strong>标准输入</strong>上产生一个文件结尾，因此在 Shell 命令当中可以使用该组合键直接<strong>退出</strong> Shell 命令行。</p>
</blockquote>
<h2 id="sha-bang"><a class="header" href="#sha-bang">Sha-Bang</a></h2>
<p><strong>Sha-Bang</strong> 是 Shell 脚本开头字符<code>#!</code>连在一起的读音（Sharp Bang），当 Shell 文件被 Linux 系统读取时，内核会通过<code>#!</code>表示的值（<code>0x23, 0x21</code>）识别出随后的解释器路径并调用，最后再将整个脚本内容传递给解释器。由于 Shell 当中<code>#</code>字符同时表示注释，因此 Shell 解释脚本文件时会自动忽略该行。本文讨论的 Shell 脚本通常以<code>#!/bin/sh</code>或者<code>#!/bin/bash</code>开头，表示当前使用的解释器为 <strong>Dash Shell</strong> 或者 <strong>Bash Shell</strong>。本文所涉及的代码都基于<code>#!/bin/bash</code>路径下的<strong>Bash Shell</strong>。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo $SHELL
/bin/bash

pi@raspberrypi:~ $ bash --version
GNU bash，版本 5.0.3(1)-release (arm-unknown-linux-gnueabihf)
</code></pre>
<p>接下来，编写一个 Bash Shell 版本的 Hello World 程序：</p>
<pre><code class="language-sh">#!/bin/bash
echo &quot;Hello Bash Shell !&quot;   # 注释
</code></pre>
<h2 id="执行方式"><a class="header" href="#执行方式">执行方式</a></h2>
<p>Shell 脚本的执行主要存在如下 5 种方式：</p>
<ol>
<li>将拥有执行权限的脚本作为命令调用，例如：<code>./hello.sh</code>；</li>
<li>显式使用 Shell 程序，将脚本文件作为参数来执行，例如：<code>sh hello.sh</code>；</li>
<li>将脚本文件重定向至 Shell 程序的标准输入，例如：<code>sh &lt; hello.sh</code>；</li>
<li>通过管道符将脚本内容输出至 Shell 程序的标准输入，例如：<code>cat hello.sh | sh</code>；</li>
<li>使用<code>source</code>命令执行，例如：<code>source hello.sh</code>；</li>
</ol>
<h2 id="字符串与引号"><a class="header" href="#字符串与引号">字符串与引号</a></h2>
<p>Shell 解释器采用了字符流过滤器模型，简而言之，就是一条命令将结果送到标准输出，这个标准输出被连接到下一条命令的标准输入，每条命令的输出结果都是自己处理之后的字符流，接受的输入都是需要进行处理的字符流，所以字符串是 Shell 当中非常重要的组成部分。</p>
<p>Shell 当中存在<code>'</code>、<code>&quot;</code>、```三种引号类型，其具体使用区别分别如下所示：</p>
<ul>
<li>
<p>单引号<code>'</code></p>
<p>当中的字符串 Shell 不会进行处理，仅在需要保持字符串原样不变的时候使用；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ writer=Hank
pi@raspberrypi:~ $ echo '本文作者是：$writer'
本文作者是：$writer
</code></pre>
</li>
<li>
<p>双引号<code>&quot;</code></p>
<p>当中的字符串 Shell 会进行处理，如果其中包含有可以求值的部分（变量、表达式、命令），则会被 Shell 替换为相应的求值结果；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ writer=Hank
pi@raspberrypi:~ $ echo &quot;本文作者是：$writer&quot;
本文作者是：Hank
</code></pre>
</li>
<li>
<p>反引号```</p>
<p>用于引用一条 Linux 命令，其作用是将该命令的执行结果输出，效果类似于</p>
<pre><code class="language-sh">&quot;$()&quot;
</code></pre>
<p>；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo 现在时间是 `date`
现在时间是 2020年 07月 12日 星期日 14:56:40 CST
</code></pre>
</li>
</ul>
<h2 id="特殊字符"><a class="header" href="#特殊字符">特殊字符</a></h2>
<ul>
<li>
<p>**<code>\*</code><strong>和</strong><code>?</code>**都是通配符，前者匹配任意个字符，后者仅匹配一个字符；</p>
</li>
<li>
<p>**<code>:</code>**表示空命令，其返回值恒为<code>0</code>，循环语句当中，可以与<code>true</code>命令等价；</p>
</li>
<li>
<p>**<code>;</code>**是分行符，标识一行命令结束，可以通过它将多条命令编写在一行；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo &quot;Hello&quot;; echo &quot;World&quot;; echo &quot;at `date`&quot;
Hello
World
at 2020年 07月 12日 星期日 16:00:29 CST
</code></pre>
</li>
<li>
<p>**<code>$</code>**可以用于获取变量或者表达式的值，结合大括号<code>${}</code>使用，可以在变量出现在字符串当中时，不与字符串内容相混淆；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ writer=Hank
pi@raspberrypi:~ $ echo ${writer} is the author of this blog
Hank is the author of this blog
</code></pre>
<p>结合小括号</p>
<pre><code class="language-sh">$()
</code></pre>
<p>可以取一个命令的值作为字符串内容，其效果与反引号</p>
<pre><code class="language-sh">`
</code></pre>
<p>相同；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo Now the time is $(date)
Now the time is 2020年 07月 12日 星期日 16:48:33 CST
</code></pre>
<p>通过双小括号</p>
<pre><code class="language-sh">$(())
</code></pre>
<p>可以取得一个数学表达式的计算结果，例如在使用</p>
<pre><code class="language-sh">*
</code></pre>
<p>运算符计算一个乘积；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo $((2*2))
4
</code></pre>
</li>
<li>
<p>**<code>.</code>**句点符号，等效于<code>source</code>命令，可用于在 Shell 进程上调用脚本；</p>
</li>
<li>
<p>**<code>\</code>**反斜线表示转义符，是一种引用单个字符的方法，也可以用于 Shell 命令的换行；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo &quot;hello&quot; \
&gt; &quot;bash&quot; \
&gt; &quot;shell&quot;
hello bash shell
</code></pre>
</li>
<li>
<p><strong>空格</strong>作为参数命令的做分隔符，例如：<code>touch a b</code>会创建<code>a</code>和<code>b</code>两个文件，而<code>touch c\ d</code>则只会创建一个名为<code>'c d'</code>文件；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ touch c\ d

pi@raspberrypi:~ $ ls -l
-rw-r--r-- 1 pi pi      0 7月  12 16:55 'c d'
</code></pre>
</li>
</ul>
<h2 id="内外部命令"><a class="header" href="#内外部命令">内/外部命令</a></h2>
<p><strong>外部命令</strong>：Shell 的绝大多数命令如同<code>/bin/ls</code>一样，是一个独立的外部可执行程序。当外部命令被调用时，本质就是调用了另外一个程序，首先 Shell 会创建子进程，然后在子进程当中运行该程序； <strong>内部命令</strong>：内建在 Shell 程序当中，由 Shell 软件内部进行实现的命令，例如：<code>cd</code>、<code>source</code>、<code>export</code>、<code>time</code>等，它们都运行在 Shell 进程当中。</p>
<p><strong>注意</strong>：如果希望脚本能够改变当前 Shell 自身的一些属性，则必须在 Shell 进程内执行调用。例如修改<code>/etc/profile</code>、<code>~/.profile</code>、<code>~/.bashrc</code>环境变量之后，必须使用<code>source</code>命令执行它们，以使其生效。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ source /etc/profile

pi@raspberrypi:~ $ source ~/.profile

pi@raspberrypi:~ $ source ~/.bashrc
</code></pre>
<h2 id="重定向"><a class="header" href="#重定向">重定向</a></h2>
<p>Shell 的设计哲学是<strong>字符流 + 过滤器</strong>，即将一个程序的输出，作为另一个程序的输入，这样就能将各种用途简单的小工具组合起来，完成一些看起来不可思议的功能。</p>
<p>默认情况下，Linux 当中的每一个进程都拥有 3 个特殊的文件描述指针：</p>
<ul>
<li><strong>标准输入</strong>：Standard Input，文件描述指针为<code>0</code>；</li>
<li><strong>标准输出</strong>：Standard Output，文件描述指针为<code>1</code>；</li>
<li><strong>标准错误输出</strong>：Standard Eror，文件描述指针为<code>2</code>；</li>
</ul>
<p><strong>IO 重定向</strong>就是捕捉命令、程序、脚本甚至代码块的输出，然后将其作为输入传递给另外的文件、命令、程序、脚本。</p>
<h3 id="输出重定向"><a class="header" href="#输出重定向">输出重定向</a></h3>
<p>输出重定向符号<code>&gt;</code>和<code>&gt;&gt;</code>，可以将<strong>标准输出</strong>重定向至一个文件当中，如果该文件不存在则创建文件。其中，前者<code>&gt;</code>会覆盖原文件内容：</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo &quot;this is line 1&quot;&gt;output.txt
pi@raspberrypi:~ $ echo &quot;this is line 2&quot;&gt;output.txt
pi@raspberrypi:~ $ echo &quot;this is line 3&quot;&gt;output.txt
pi@raspberrypi:~ $ cat output.txt

this is line 3
</code></pre>
<p>后者<code>&gt;&gt;</code>则会在原文件尾部追加新的内容：</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo &quot;this is line 1&quot;&gt;&gt;output.txt
pi@raspberrypi:~ $ echo &quot;this is line 2&quot;&gt;&gt;output.txt
pi@raspberrypi:~ $ echo &quot;this is line 3&quot;&gt;&gt;output.txt
pi@raspberrypi:~ $ cat output.txt

this is line 1
this is line 2
this is line 3
</code></pre>
<h3 id="输入重定向"><a class="header" href="#输入重定向">输入重定向</a></h3>
<p>输出重定向符号<code>&lt;</code>和<code>&lt;&lt;</code>，用于将<strong>标准输入</strong>重定向至一个文件。如果<code>&lt;</code>后跟着一个 Shell 脚本文件，则相当于将<code>.sh</code>脚本中的命令逐条输入至 Shell 程序当中执行：</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ cat&lt;hello.sh
#!/bin/bash
echo &quot;Hello Bash Shell !&quot;   # 注释

pi@raspberrypi:~ $ bash &lt; hello.sh
Hello Bash Shell !
</code></pre>
<p><code>&lt;&lt;</code>可以用于 <strong>Here Document</strong>， 即将文本直接写在 Shell 脚本之中，并以添加终止符<code>EOF</code>（即 Linux 系统读取至文件结尾时所返回的信号值<code>-1</code>），该文本相当于一份独立的文件内容，例如：执行下面的<code>hello.sh</code>脚本以后：</p>
<pre><code class="language-sh">#!/bin/bash
echo &quot;文件 hello 不存在&quot;
ls -l   # 列出当前目录所有文件

# 使用 Here Document 方式产生 hello.c 文件
cat&gt;hello.c&lt;&lt;EOF

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main(void){
    printf(&quot;Hello World\n&quot;);
    return EXIT_SUCCESS;
}
EOF

# 编译 hello.c
cc -W -Wall -o hello hello.c
ls -l   # 列出当前目录所有文件

# 执行 hello，然后清除新生成的文件
./hello
rm hello hello.c
</code></pre>
<p>将会动态生成一个<code>hello.c</code>源文件，然后编译产生二进制文件<code>hello</code>，最后执行并且展示结果，同时删除新生成的 2 个文件。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ ./hello.sh

文件 hello 不存在
总用量 1
-rwxrwxrwx 1 pi pi    234 7月  12 18:51  hello.sh
总用量 3
-rwxr-xr-x 1 pi pi   7980 7月  12 18:51  hello
-rw-r--r-- 1 pi pi    111 7月  12 18:51  hello.c
-rwxrwxrwx 1 pi pi    234 7月  12 18:51  hello.sh
Hello World
</code></pre>
<blockquote>
<p><strong>注意</strong>：<strong>Here Document</strong> 通常用于进行复杂的多行文本输入时，从而代替<code>echo</code>命令繁琐的硬编码操作。</p>
</blockquote>
<h2 id="管道"><a class="header" href="#管道">管道</a></h2>
<p>管道符<code>|</code>用于连接 Linux 命令，前一条命令的标准输出会成为下一条命令的标准输入。管道的最大特点在于是管道符<code>|</code>两边分别属于不同的进程。例如：从<code>dmesg</code>输出的内核日志信息中，通过<code>grep</code>查找 USB 相关的内容。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ dmesg | grep USB

[    0.369739] xhci_hcd 0000:01:00.0: new USB bus registered, assigned bus number 1
[    0.372689] usb usb1: New USB device found, idVendor=1d6b, idProduct=0002, bcdDevice= 4.19
[    0.372704] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    0.373268] hub 1-0:1.0: USB hub found
[    0.373828] xhci_hcd 0000:01:00.0: new USB bus registered, assigned bus number 2
[    0.373846] xhci_hcd 0000:01:00.0: Host supports USB 3.0 SuperSpeed
[    0.374254] usb usb2: New USB device found, idVendor=1d6b, idProduct=0003, bcdDevice= 4.19
[    0.374267] usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
[    0.374779] hub 2-0:1.0: USB hub found
[    0.383583] usbhid: USB HID core driver
[    0.737890] usb 1-1: new high-speed USB device number 2 using xhci_hcd
[    0.920531] usb 1-1: New USB device found, idVendor=2109, idProduct=3431, bcdDevice= 4.21
[    0.920545] usb 1-1: New USB device strings: Mfr=0, Product=1, SerialNumber=0
[    0.920558] usb 1-1: Product: USB2.0 Hub
[    0.922299] hub 1-1:1.0: USB hub found
</code></pre>
<h2 id="常量与变量"><a class="header" href="#常量与变量">常量与变量</a></h2>
<p>Shell 支持多种进制的整型<strong>常量</strong>，例如以<code>0</code>开头的八进制，以<code>0x</code>开头的十六进制。对于非八进制、十进制、十六进制的整数，可以表示为<code>进制#数字</code>格式，例如：三进制数<code>(120)₃</code>可以表示为<code>3#120</code>，转换为十进制值为<code>15</code>。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo $((3#120))
15
</code></pre>
<p>Shell 中的<strong>变量</strong>在使用前不需要声明，赋值时可以直接使用变量名，且赋值的等号<code>=</code>两边不能有空格。变量定义之后，引用变量时一定需要使用<code>$</code>符号。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ writer=Hank
pi@raspberrypi:~ $ echo ${writer}
Hank

pi@raspberrypi:~ $ writer=Jack
pi@raspberrypi:~ $ echo $writer
Jack
</code></pre>
<p>Shell <strong>变量没有类型</strong>，例如<code>annum=2020</code>，既可以作为十进制整数<code>2020</code>直接参与算术运算，也可以作为字符串来进行处理。</p>
<pre><code class="language-sh"># 使用 let 计算一个算术表达式并且赋值给变量
pi@raspberrypi:~ $ annum=2020
pi@raspberrypi:~ $ let &quot;annum+=1&quot;
pi@raspberrypi:~ $ echo $annum
2021

# 将字符串变量中的 202 替换成为 203
pi@raspberrypi:~ $ b=${annum/202/203}
pi@raspberrypi:~ $ echo $b
2031
</code></pre>
<p>Shell <strong>变量有作用域</strong>，默认为对整个 Shell 文件有效的<strong>全局变量</strong>。<strong>局部变量</strong>则需要使用<code>local</code>关键字进行声明，其只在声明所在的块或者函数当中可见。</p>
<pre><code class="language-sh">#!/bin/bash
# test.sh
test() {
    variable1=GLOBAL
    local variable2=LOCAL
    echo &quot;函数内部，variable1=$variable1, variable2=$variable2&quot;
}

test

echo &quot;函数外部，variable1=$variable1, variable2=$variable2&quot;
pi@raspberrypi:~ $ ./test.sh

函数内部，variable1=GLOBAL, variable2=LOCAL
函数外部，variable1=GLOBAL, variable2=
</code></pre>
<p><code>?</code>问号也是一个变量，通过<code>$?</code>可以引用上一条命令的返回值，但是该值只能使用一次，使用完以后就会被目前命令的返回值所替换。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ false

# false 命令返的回值恒为 1
pi@raspberrypi:~ $ echo $?
1

# 使用 echo 查看 1 次后，变量 ? 的值会就被 echo 命令的返回值 0 覆盖
pi@raspberrypi:~ $ echo $?
0
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<p>环境变量是可以改变 Shell 行为的变量，每个进程都拥有各自的环境变量，以用于保存进程相关的各种信息。环境变量的定义通常都是约定俗成的，例如：<code>PATH</code>定义了 Shell 进程查找命令程序的路径。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo $PATH

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games
</code></pre>
<p>Shell 当中的任何变量都可以通过<code>export</code>导出为环境变量，环境变量可以被子进程继承，因此也可以被视为父子进程信息传递的一种方式。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ export PATH=&quot;$PATH:/workspace&quot;

pi@raspberrypi:~ $ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/workspace
</code></pre>
<h2 id="位置参数"><a class="header" href="#位置参数">位置参数</a></h2>
<p><strong>位置参数</strong>是指调用 Shell 脚本时，按照命令行位置进行引用的参数。脚本当中按照<code>$0</code>、<code>$1</code>、<code>$2</code>的顺序逐个进行引用，依此类推。其中<code>$0</code>就代表命令本身。</p>
<pre><code class="language-sh">#!/bin/bash
# parameter.sh
echo $0
echo $1
echo $2
echo $3
pi@raspberrypi:~ $ ./parameter.sh 2019 2020 2021

./parameter.sh
2019
2020
2021
</code></pre>
<p>命令行参数相关的特殊变量还有<code>$#</code>、<code>$*</code>、<code>$@</code>，其使用方法如下所示：</p>
<ul>
<li><strong><code>$#</code></strong>：代表命令行参数的个数；</li>
<li><strong><code>$\*</code></strong>：代表<strong>全部</strong>命令行参数，全部参数作为一个字符串；</li>
<li><strong><code>$@</code></strong>：代表<strong>所有</strong>命令行参数，每个参数都是一个独立的字符串；</li>
</ul>
<pre><code class="language-sh">#!/bin/bash
# parameter.sh
echo &quot;命令行参数个数：$#&quot;

touch &quot;$*&quot;   # 由于将全部参数作为 1 个字符串，所以使用全部参数为名称创建 1 个文件
ls -l

touch &quot;$@&quot;   # 因为参数为 3 个字符串，所以分别使用每个参数作为名称，共创建 3 个文件
ls -l
pi@raspberrypi:~ $ ./parameter.sh 1 2 3

命令行参数个数：3
总用量 620
-rw-r--r-- 1 pi pi      0 7月  13 04:31 '1 2 3'
总用量 620
-rw-r--r-- 1 pi pi      0 7月  13 04:31 '1 2 3'
-rw-r--r-- 1 pi pi      0 7月  13 04:31  1
-rw-r--r-- 1 pi pi      0 7月  13 04:31  2
-rw-r--r-- 1 pi pi      0 7月  13 04:31  3
</code></pre>
<h2 id="操作符"><a class="header" href="#操作符">操作符</a></h2>
<p>Shell 当中的每一条命令同时也是一个逻辑表达式，其返回值为<code>0</code>表示真，返回值为非<code>0</code>表示假，该值本质上就是当前命令所对应<code>main()</code>函数的返回值，可以通过<code>$?</code>来进行获取。Shell 支持基本的数学运算符号以及各种逻辑操作符。</p>
<p><strong>数学运算符</strong>包括<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>以及幂运算<code>**</code>，Bash Shell 本身只支持整数运算，如果需要使用到浮点运算，则可以调用<code>bc</code>和<code>dc</code>等外部命令。</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ echo $((3.14+2))

-bash: 3.14+2：语法错误: 无效的算术运算符 (错误符号是 &quot;.14+2&quot;)
</code></pre>
<p><strong>逻辑操作符</strong>包括<code>&amp;&amp;</code>和<code>||</code>，分别代表逻辑<strong>与</strong>和逻辑<strong>或</strong>。对于逻辑与<code>&amp;&amp;</code>而言，如果左侧表达式为<code>false</code>，则右侧表达式无需执行即可确定整个表达式的结果为<code>false</code>；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ true &amp;&amp; date
2020年 07月 13日 星期一 04:58:28 CST

pi@raspberrypi:~ $ false &amp;&amp; date
</code></pre>
<p>对于逻辑或<code>||</code>而言，如果左侧表达式为<code>true</code>，则右侧表达式无需执行即可确定整个表达式的结果为<code>true</code>；</p>
<pre><code class="language-sh">pi@raspberrypi:~ $ true || date

pi@raspberrypi:~ $ false || date
2020年 07月 13日 星期一 05:01:43 CST
</code></pre>
<h2 id="脚本返回值"><a class="header" href="#脚本返回值">脚本返回值</a></h2>
<p>通常情况下，Shell 脚本在最后都应该拥有一个返回值，如果未显式的通过<code>exit</code>指定返回值，则默认使用脚本最后一条命令的返回值；</p>
<pre><code class="language-sh">#!/bin/bash
# hello.sh
echo &quot;hello world&quot;
false    # false 的返回值为 1
exit 0   # 显式声明返回值为 0
pi@raspberrypi:~ $ ./hello.sh

hello world
</code></pre>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<p>Shell 脚本当中的函数有 2 种定义方法，其中一种是通过<code>function</code>关键字进行定义：</p>
<pre><code class="language-sh">function function_name(){
  # command
}
</code></pre>
<p>另外一种与 C 语言当中函数的定义方式相类似，这种方式可移植性更好，更加推荐使用：</p>
<pre><code class="language-sh">function_name(){
  # command
}
</code></pre>
<p>Shell 当中的函数必须在其被调用之前完整的进行定义，调用函数时直接通过函数名称<code>function_name</code>直接调用即可；</p>
<pre><code class="language-sh">#!/bin/bash
# test.sh
echo &quot;Shell 函数调用示例：&quot;

function test() {
  echo &quot;函数 test 被调用!&quot;
}
test

echo &quot;函数调用结束!&quot;
pi@raspberrypi:~ $ ./test.sh

Shell 函数调用示例：
函数 test 被调用!
函数调用结束!
</code></pre>
<h2 id="条件测试"><a class="header" href="#条件测试">条件测试</a></h2>
<p>Shell 提供了一系列条件测试运算符，用于判断某种条件是否成立，条件测试运算符主要包含如下 3 种：</p>
<pre><code class="language-sh">test expression
[ expresssion ]    # 条件和左右括号之间必须带有空格
[[ expression ]]   # 新版本 Bash Shell 提供
</code></pre>
<h3 id="文件测试"><a class="header" href="#文件测试">文件测试</a></h3>
<p>文件测试通常用于判断文件属性，常用的文件测试条件如下所示：</p>
<table><thead><tr><th>条件</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>-e</code>或<code>-a</code></td><td>文件存在（<code>-a</code>已弃用）</td><td><code>[ -e ~/.bashrc ]</code></td></tr>
<tr><td><code>-f</code></td><td>普通文件</td><td><code>[ -f ~/.profile ]</code></td></tr>
<tr><td><code>-s</code></td><td>文件长度不为<code>0</code></td><td><code>[ -s /etc/mtab ]</code></td></tr>
<tr><td><code>-d</code></td><td>文件是目录</td><td><code>[ -d /etc ]</code></td></tr>
<tr><td><code>-b</code></td><td>文件是块设备文件</td><td><code>[ -b /dev/sda ]</code></td></tr>
<tr><td><code>-c</code></td><td>文件是字符设备</td><td><code>[ -c /dev/ttyS0 ]</code></td></tr>
<tr><td><code>-p</code></td><td>文件是管道</td><td><code>[ -p /tmp/fifo ]</code></td></tr>
<tr><td><code>-h/-L</code></td><td>文件是符号链接</td><td><code>[ -L /etc/mtab ]</code></td></tr>
<tr><td><code>-S</code></td><td>文件是 Socket</td><td><code>[ -S /tmp/socket ]</code></td></tr>
<tr><td><code>-t</code></td><td>是否为关联到终端的文件描述符</td><td><code>[ -t /dev/stdout ]</code></td></tr>
<tr><td><code>-r</code></td><td>文件可读</td><td><code>[ -r ~/.bashrc ]</code></td></tr>
<tr><td><code>-w</code></td><td>文件可写</td><td><code>[ -w ~/.profile ]</code></td></tr>
<tr><td><code>-x</code></td><td>文件可执行</td><td><code>[ -x /bin/ls ]</code></td></tr>
<tr><td><code>-g</code></td><td>文件有 <strong>SGID</strong> 标识</td><td><code>[ -g /bin/su ]</code></td></tr>
<tr><td><code>-u</code></td><td>文件有 <strong>SUID</strong> 标识</td><td><code>[ -u /usr/bin/sudo ]</code></td></tr>
<tr><td><code>-k</code></td><td>具有粘滞位</td><td><code>[ -k /tmp ]</code></td></tr>
<tr><td><code>-O</code></td><td>测试者是文件拥有者</td><td><code>[ -O ~/.bashrc ]</code></td></tr>
<tr><td><code>-G</code></td><td>文件的组 ID 与测试者相同</td><td><code>[ -G ~/.profile ]</code></td></tr>
<tr><td><code>-N</code></td><td>文件从最后一次查看到现在，是否有被修改过</td><td><code>[ -N ~/.profile ]</code></td></tr>
<tr><td><code>file1 -nt file2</code></td><td>文件<code>file1</code>比文件<code>file2</code>更新</td><td><code>[ ~/.bashrc –nt ~/.profile ]</code></td></tr>
<tr><td><code>file1 -ot file2</code></td><td>文件<code>file1</code>比文件<code>file2</code>更旧</td><td><code>[ ~/.bashrc –ot ~/.profile ]</code></td></tr>
<tr><td><code>file1 -ef file2</code></td><td><code>file1</code>和<code>file2</code>都是同一个文件的硬链接</td><td><code>[ /usr/bin/test -ef /usr/bin/\[ ]</code></td></tr>
<tr><td><code>!</code></td><td>取反测试结果，如果没有条件则返回<code>true</code></td><td><code>[ ! -d ~/.profile ]</code></td></tr>
</tbody></table>
<h3 id="整数比较"><a class="header" href="#整数比较">整数比较</a></h3>
<table><thead><tr><th>条件</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>-eq</code></td><td>等于</td><td><code>[ &quot;$m&quot; -eq &quot;$n&quot; ]</code></td></tr>
<tr><td><code>-ne</code></td><td>不等于</td><td><code>[ &quot;$m&quot; -ne &quot;$n&quot; ]</code></td></tr>
<tr><td><code>-gt</code></td><td>大于</td><td><code>[ &quot;$m&quot; -gt &quot;$n&quot; ]</code></td></tr>
<tr><td><code>-ge</code></td><td>大于等于</td><td><code>[ &quot;$m&quot; -ge &quot;$n&quot; ]</code></td></tr>
<tr><td><code>-lt</code></td><td>小于</td><td><code>[ &quot;$m&quot; -lt &quot;$n&quot; ]</code></td></tr>
<tr><td><code>-le</code></td><td>小于等于</td><td><code>[ &quot;$m&quot; -le &quot;$n&quot; ]</code></td></tr>
<tr><td><code>&lt;</code></td><td>小于，需要以<code>(())</code>方式测试</td><td><code>(( &quot;$m&quot; &lt; &quot;$n&quot;))</code></td></tr>
<tr><td><code>&lt;=</code></td><td>小于等于，需要以<code>(())</code>方式测试</td><td><code>(( &quot;$m&quot; &lt;= &quot;$n&quot;))</code></td></tr>
<tr><td><code>&gt;</code></td><td>大于，需要以<code>(())</code>方式测试</td><td><code>(( &quot;$m&quot; &gt; &quot;$n&quot;))</code></td></tr>
<tr><td><code>&gt;=</code></td><td>大于等于，需要以<code>(())</code>方式测试</td><td><code>(( &quot;$m&quot; &gt;= &quot;$n&quot;))</code></td></tr>
</tbody></table>
<h3 id="字符串比较"><a class="header" href="#字符串比较">字符串比较</a></h3>
<table><thead><tr><th>条件</th><th>含义</th><th>示例</th></tr></thead><tbody>
<tr><td><code>=</code>或<code>==</code></td><td>相等，<code>==</code>在<code>[]</code>和<code>[[]]</code>里的行为可能会表现不同</td><td><code>[ &quot;$str1&quot; = &quot;$str2&quot; ]</code></td></tr>
<tr><td><code>!=</code></td><td>不相等</td><td><code>[ &quot;$str1&quot; != &quot;$str2&quot; ]</code></td></tr>
<tr><td><code>&gt;</code></td><td>大于，按照 ASCII 顺序进行比较，在<code>[]</code>中使用时需要转义为<code>\&gt;</code></td><td><code>[ &quot;$str1&quot; \&gt; &quot;$str2&quot; ]</code></td></tr>
<tr><td><code>&lt;</code></td><td>小于，按照 ASCII 顺序进行比较，在<code>[]</code>中使用时需要转义为<code>\&lt;</code></td><td><code>[ &quot;$str1&quot; \&lt; &quot;$str2&quot; ]</code></td></tr>
<tr><td><code>-z</code></td><td>长度为 <code>0</code></td><td><code>[ -z &quot;$str&quot; ]</code></td></tr>
<tr><td><code>-n</code></td><td>长度不为 <code>0</code>，在<code>[]</code>当中使用时，需要将字符串放入<code>&quot;&quot;</code>里面</td><td><code>[ -n &quot;$str&quot; ]</code></td></tr>
</tbody></table>
<h3 id="混合比较"><a class="header" href="#混合比较">混合比较</a></h3>
<p>条件测试还支持在多个<strong>表达式</strong>之间进行逻辑运算，其中<code>-a</code>表示<strong>与运算</strong>，<code>-o</code>表示<strong>或运算</strong>。下面的示例用于测试命令行参数提供的整数是否介于<code>0 ~ 100</code>之间，若位于该区间范围输出<code>yes</code>，不在则向控制台输出<code>no</code>。</p>
<pre><code class="language-sh">#!/bin/bash
# compare.sh
[ &quot;$1&quot; -ge 0 -a &quot;$1&quot; -le 100 ] &amp;&amp; echo yes || echo no
[ &quot;$1&quot; -lt 0 -o &quot;$1&quot; -gt 100 ] &amp;&amp; echo no || echo yes
pi@raspberrypi:~ $ ./compare.sh 0
yes
yes

pi@raspberrypi:~ $ ./compare.sh 85
yes
yes

pi@raspberrypi:~ $ ./compare.sh 100
yes
yes

pi@raspberrypi:~ $ ./compare.sh 101
no
no
</code></pre>
<h2 id="条件判断"><a class="header" href="#条件判断">条件判断</a></h2>
<h3 id="if-then"><a class="header" href="#if-then">if then</a></h3>
<p>根据<code>if</code>表达式的逻辑值，决定是否执行<code>then</code>里的内容。通常<code>if</code>会与条件测试表达式一同使用，但也可以结合其它命令或者函数。最后，<code>if</code>需要通过<code>fi</code>结束条件流程。</p>
<pre><code class="language-sh">if 条件
  then
    代码块
fi
</code></pre>
<p>如果<code>if</code>与<code>then</code>编写在相同的行，则需要额外再添加一个<code>;</code>分号：</p>
<pre><code class="language-sh">if 条件; then
  代码块
fi
</code></pre>
<p>下面代码当中，仅当<code>if</code>后面的表达式为<code>true</code>时，<code>then</code>里的<code>echo</code>命令才会得到执行。</p>
<pre><code class="language-sh">#!/bin/bash
# decide.sh

if true
  then
    echo &quot;true 分支&quot;
fi

if false; then
  echo &quot;false 分支&quot;
fi
pi@raspberrypi:~ $ ./decide.sh

true 分支
</code></pre>
<h3 id="if-then-else"><a class="header" href="#if-then-else">if then else</a></h3>
<p><strong>条件</strong>流程控制语句还可以拥有一个<code>else</code>分支，用于条件不成立的情况。</p>
<pre><code class="language-sh">if 条件; then
    代码块 1
  else
    代码块 2
fi
</code></pre>
<p>这样<code>then</code>和<code>else</code>后面各有一个代码块，根据<code>if</code>后面表达式的逻辑值来决定具体执行哪个，下面是一个具体的示例：</p>
<pre><code class="language-sh">#!/bin/bash
# decide.sh
condition=false

if $condition; then
    echo &quot;true 分支&quot;
  else
    echo &quot;false 分支&quot;
fi
pi@raspberrypi:~ $ ./decide.sh

false 分支
</code></pre>
<h3 id="if-then-elif-else"><a class="header" href="#if-then-elif-else">if then elif else</a></h3>
<p>如果存在多个并列并且互斥的条件，则可用采用<code>elif</code>来依次判断条件：</p>
<pre><code class="language-sh">if 条件1; then
    # 代码块 1
  elif 条件2; then
    # 代码块 2
  # ... ...
  elif 条件n; then
    # 代码块 n
  else
    # 代码块 n+1
fi
</code></pre>
<p>程序会依次测试每一个条件，如果条件<code>n</code>符合，则执行代码块<code>n</code>，如果所有条件均不符合，则执行最后的<code>else</code>分支（非必须）。</p>
<pre><code class="language-sh">#!/bin/bash
# test.sh

# 判断脚本第 1 个命令行参数是否为 1
if [ &quot;$1&quot; -eq 1 ]; then
  echo &quot;1&quot;
  # 判断脚本第 1 个命令行参数是否为 2 或 3
  elif [ &quot;$1&quot; -eq 2 -o &quot;$1&quot; -eq 3 ]; then
    echo &quot;2 或者 3&quot;
  # 判断脚本第 1 个命令行参数是否为介于 4 ~ 7 之间
  elif [ &quot;$1&quot; -ge 4 -a &quot;$1&quot; -lt 7 ]; then
    echo &quot;[4, 7)&quot;
  # 如果都不是，则输出其它
  else
    echo &quot;其它&quot;
fi
pi@raspberrypi:~ $ ./test.sh 1
1

pi@raspberrypi:~ $ ./test.sh 3
2 或者 3

pi@raspberrypi:~ $ ./test.sh 5
[4, 7)

pi@raspberrypi:~ $ ./test.sh 9
其它
</code></pre>
<h2 id="循环结构"><a class="header" href="#循环结构">循环结构</a></h2>
<p>Bash Shell 支持<code>for</code>、<code>while</code>、<code>until</code>三种不同类型的循环，其循环体当中的内容必须包含在<code>do</code>和<code>done</code>语句之间。</p>
<h3 id="for-循环"><a class="header" href="#for-循环">for 循环</a></h3>
<p>for 循环的<code>列表</code>是一个由空格分隔的字符串列表，支持通配符。如果缺省，则会自动使用当前的命令行参数列表<code>$@</code>。</p>
<pre><code class="language-sh">for 参数 in [列表]
  do
    命令
  done
</code></pre>
<p>下面的示例会根据输入的参数，分别循环打印工作日和非工作日：</p>
<pre><code class="language-sh">#!/bin/bash
# week.sh

if [ &quot;$1&quot; == &quot;工作日&quot; ]; then
  for wd in Monday Tuesday Wednesday Thursday Friday; do
    echo $wd
  done
elif [ &quot;$1&quot; == &quot;非工作日&quot; ]; then
  for wd in Saturday Sunday
    do
      echo $wd
    done
else
  echo &quot;输入错误！&quot;
fi
pi@raspberrypi:~ $ ./week.sh
输入错误！

pi@raspberrypi:~ $ ./week.sh 工作日
Monday
Tuesday
Wednesday
Thursday
Friday

pi@raspberrypi:~ $ ./week.sh 非工作日
Saturday
Sunday
</code></pre>
<p><code>列表</code>当中的通配符会被 Shell 展开，下面示例脚本当中，<code>*.c</code>会被展开为当前目录下所有<code>.c</code>后缀的非隐藏文件：</p>
<pre><code class="language-sh">#!/bin/bash
# file.sh

for filename in *.c
  do
    echo $filename
  done
pi@raspberrypi:~ $ ./file.sh

function.c
main.c
</code></pre>
<p>Bash Shell 同时也通过双小括号<code>(( ))</code>支持 C 风格的<code>for</code>循环。</p>
<pre><code class="language-sh">for ((表达式 1; 表达式 2; 表达式 3))
  do
    命令
  done
</code></pre>
<p>其中，<code>表达式1</code>是循环执行之前的初始化，<code>表达式2</code>是一个代表循环逻辑测试的表达式，<code>表达式3</code>是每次循环体执行完成之后的处理</p>
<pre><code class="language-sh">#!/bin/bash
# loop.sh

for ((i=0; i &lt; 7; i++))
  do
    echo $i
  done
pi@raspberrypi:~ $ ./loop.sh

0
1
2
3
4
5
6
</code></pre>
<h3 id="while-循环"><a class="header" href="#while-循环">while 循环</a></h3>
<p>while 循环根据测试条件，反复执行循环体直至条件为<strong>假</strong>，同样拥有 <strong>Shell</strong> 和 <strong>C</strong> 两种风格。</p>
<pre><code class="language-sh"># Shell 风格
while [条件]
  do
    命令
  done

# C 风格
while ((表达式))
  do
    命令
  done
</code></pre>
<p>接下来的示例代码，同时使用 Shell 和 C 两种风格的<code>while</code>循环，该示例会根据命令行参数的个数来打印它们：</p>
<pre><code class="language-sh">#!/bin/bash
# loop.sh

i=0
# Shell 风格循环
while [ &quot;$i&quot; -le &quot;$#&quot; ]
  do
    eval tmp=\$$i    # 以变量 i 的值作为变量名再进行取值
    echo &quot;$tmp&quot;
    i=`expr $i + 1`  # 获取参数个数，并作为 C 风格循环的索引长度
  done

echo

j=0
# C 风格循环
while ((j++ &lt;= i))
  do
    eval tmp=\$$j
    echo &quot;$tmp&quot;
  done
pi@raspberrypi:~ $ ./loop.sh 1 2 3 4 5

./loop.sh
1
2
3
4
5

1
2
3
4
5
</code></pre>
<h3 id="until-循环"><a class="header" href="#until-循环">until 循环</a></h3>
<p><code>until</code>循环与<code>while</code>类似，但是<code>util</code>循环是在条件为<strong>假</strong>时执行循环体，直至条件为<strong>真</strong>时才结束循环。</p>
<pre><code class="language-sh">until [条件]
  do
    命令
  done

# 或者
until ((表达式))
  do
    命令
  done
</code></pre>
<h2 id="跳出循环"><a class="header" href="#跳出循环">跳出循环</a></h2>
<p>Shell 循环结构当中，可以使用<code>break</code>或者<code>continue</code>跳出循环，它们都可以携带一个用于标识所要跳出<strong>循环层数</strong>的数值，该数值缺省情况下为<code>1</code>，表示仅跳出当前所在循环。</p>
<h3 id="break"><a class="header" href="#break">break</a></h3>
<p>Bash Shell 当中的<code>break</code>关键字用于中断整个循环，其具体用法如下：</p>
<pre><code class="language-sh">break n
</code></pre>
<p><code>n</code>表示跳出循环的层数，如果省略<code>n</code>，则表示仅中断当前循环。<code>break</code>关键字通常与<code>if</code>语句联用，即满足条件时中断循环。例如下面代码用于输出一个<code>4*4</code>的矩阵：</p>
<pre><code class="language-sh">#!/bin/bash
# break.sh

i=0
# 外层循环
while ((++i)); do
  j=0;
  # 内层循环
  while ((++j)); do
    if((i&gt;4)); then
      break 2  # 中断内外 2 层循环
    fi
    if((j&gt;4)); then
      break    # 仅中断内层循环
    fi
    printf &quot;%-4d&quot; $((i*j))
  done
  printf &quot;\n&quot;
done
pi@raspberrypi:~ $ ./break.sh

1   2   3   4
2   4   6   8
3   6   9   12
4   8   12  16
</code></pre>
<h3 id="continue"><a class="header" href="#continue">continue</a></h3>
<p>Bash Shell 当中的<code>continue</code>关键字用于跳出本次循环，其具体用法如下：</p>
<pre><code class="language-sh">continue n
</code></pre>
<p>其中，<code>n</code>表示循环层数，缺省值为<code>1</code>。即如果省略，则<code>continue</code>仅跳出其所在的循环语句，忽略本次循环当中剩余代码的执行，直接进入下一次循环。如果将<code>n</code>的值设置为<code>2</code>，那么<code>continue</code>会对内外两层的循环语句都有效，不但会跳出内层循环，还会跳出外层循环。<code>continue</code>通常与<code>if</code>配合使用，在满足条件时跳出本次循环。</p>
<pre><code class="language-sh">#!/bin/bash
# continue.sh

for((i=1; i&lt;=5; i++)); do
  for((j=1; j&lt;=5; j++)); do
    if((i*j==12)); then
      continue 2     # 跳出内外 2 层循环
    fi
    printf &quot;%d*%d=%-4d&quot; $i $j $((i*j))
  done
  printf &quot;\n&quot;
done
pi@raspberrypi:~ $ ./continue.sh

1*1=1   1*2=2   1*3=3   1*4=4   1*5=5
2*1=2   2*2=4   2*3=6   2*4=8   2*5=10
3*1=3   3*2=6   3*3=9   4*1=4   4*2=8   5*1=5   5*2=10  5*3=15  5*4=20  5*5=25
</code></pre>
<h2 id="分支结构-case-in-esac"><a class="header" href="#分支结构-case-in-esac">分支结构 case in esac</a></h2>
<p>Shell 通过<code>case in esac</code>语句实现分支结构，该结构与 C 语言中的<code>switch case</code>语句非常类似。</p>
<pre><code class="language-sh">case &quot;$variable&quot; in
  &quot;$condition1&quot;)
    命令
  ;;
  &quot;$condition2&quot;)
    命令
  ;;
esac
</code></pre>
<p>每个条件行都使用<code>)</code>结尾，每个条件块都以<code>;;</code>结尾（），关键字<code>esac</code>用于终止整个分支结构。下面示例脚本当中，会根据第 1 个命令行参数的值，分别打印对应的提示信息，当所有条件都不匹配时，最后会通过通配符<code>*</code>拦截执行流程，打印一条提示信息：</p>
<pre><code class="language-sh">#!/bin/bash
# switch.sh

case &quot;$1&quot; in
  &quot;A&quot;)
    echo &quot;当前命令行参数为 A&quot;
  ;;
  &quot;B&quot;)
    echo &quot;当前命令行参数为 B&quot;
  ;;
  &quot;C&quot;)
    echo &quot;当前命令行参数为 C&quot;
  ;;
  *)
    echo &quot;当前命令行参数 A B C 都不是！&quot;
  ;;
esac
pi@raspberrypi:~ $ ./switch.sh A
当前命令行参数为 A

pi@raspberrypi:~ $ ./switch.sh B
当前命令行参数为 B

pi@raspberrypi:~ $ ./switch.sh C
当前命令行参数为 C

pi@raspberrypi:~ $ ./switch.sh D
当前命令行参数 A B C 都不是！
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../shell/shell编程.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../shell/linux速查.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../shell/shell编程.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../shell/linux速查.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
